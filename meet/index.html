<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<div style="width: 400px;height: 100px">
	<span style="float: left;width: auto;height: 100%;background: red;"></span>
</div>
</body>
<script type="text/javascript">
	//递归
	function callSelf(a){
		
		console.log(a);
		if(a==1)
			return;
		setTimeout(function(){
			a--;
			callSelf(a);
		},300)

	}
	function cal(arr){
		
	}

	let add = (function(){
		let arr = [];
		return function(){
			let it = arguments[0];
			
			if(arguments.length===0)
				cal(arr);
			else
				arr.push(it);
			console.log(arr)
			return arr;
		}
	})();
	add(1);
	add(2);
	add(3);
	add();
	var foo = {n: 1};
	var bar = foo;

	// foo = {n:2};
	// foo.x = foo;  not undefined
	
	//foo.x = foo = {n: 2};  undefined
	foo.x = bar = {n:2};
	// foo.x = foo = {n: 2};  
	console.log(foo)

	function Ofo(){}
	function Bike(){
		this.useTime = 0;
	}
	var myOfo = new Ofo();
	Ofo.prototype = new Bike();
	var heiOfo = new Ofo();

	console.log(myOfo)
	// function duplicate(){
	// 	let arg = arguments,
	// 		arr = [];
	// 	arguments[0].map(function(val){
	// 		arr.push(val);
	// 	})
	// 	return [...arguments[0],...arr];
	// }
	// let ret = 	duplicate([1,2,3,4,5]);
	// console.log(ret)

	function Parent(age) {
		this.age = age;
		this.friends = [];
		this.sayAge=function()
		{
		console.log(this.age);
		}
	}
	function Child(){

	}
	Child.prototype =new Parent(2);  //继承原型上的方法和对象
	let people = new Child();

	people.friends.push('duhao');
	let people2 = new Child();
	console.log(people.friends,people2.age); //['duhao'] 2

	var out =  25,
		inner = {
			out : 20,
			func : function(){
				var out = 30;
				console.log(1);
				return this.out
		    }
		}
function fn(...arg){
	arg[2] = 10;

	console.log(arg);
}
fn(1,2,3);
function arrayIndex(arr1,arr2){
	let arr = [];
	arr1.map(function(val){
		if(arr2.indexOf(val)===-1){
			arr.push(val);
		}
	});
	console.log(arr);
};

//算法
//排序类
//快速排序
let arr = [2,3,4,52,1,67,34376,324,2,57,4354,72];
function fastSort(arr){
	let mid,
		left=[],
		right=[];
	if(arr.length <=1)
		return arr;
	mid = arr[Math.floor(arr.length/2)]; //center num
	left = [];
	right = [];
	arr.map(function(val){
		if(val>mid)
			right.push(val);
		if(val<mid)
			left.push(val);
	})
	return [].concat(fastSort(left),mid,fastSort(right));
}
//冒泡排序
function scopeSort(arr){
	let len = arr.length,
		now;
	for(let i=0;i<len;i++){
		for(let j =0;j<len-i-1;j++){
			if(arr[j]>arr[j+1]){
				now = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = now;
			}
		}
	}
}
//折中查找
function halfFind(arr,val){
	let mind = Math.floor(arr.length/2);
	while(mind>=0){
		
		if(val==arr[mind])
			return val;
		if(val>arr[mind]){
			arr = arr.splice(mind,arr.length-1);
		}else{
			arr = arr.splice(0,mind);
		}
		mind = Math.floor(arr.length-1/2);
	
	}
	return 'can not find';
}
console.log(halfFind([1,2,3,4,5],0));

function fn(){
	let ret = '';
	ret+=arguments[0];
	let callFn = function(){
		ret+=arguments[0];
		return callFn;
	}
	callFn.toString = function(){
		console.log(ret)
		return ret
	};
	return callFn;
}


//定时器研究
//第一个推入队列中
setTimeout(function(){
  console.log("1");
},0);
//第三个推入队列中
setTimeout(function(){
 console.log("2");
},1000);
//第二个推入队列中
setTimeout(function(){
  console.log("3");
},0);

</script>
</html>